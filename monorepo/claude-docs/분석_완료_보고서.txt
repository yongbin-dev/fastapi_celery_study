================================================================================
  모델 구조 및 관계 분석 - 완료 보고서
================================================================================

작업 일시: 2025-11-13
분석 대상: FastAPI + Celery + ML 모노레포 (packages/shared, packages/celery_worker)

================================================================================
  1. 분석 범위
================================================================================

✓ 모델 파일 분석 (6개):
  - base.py (Base 클래스)
  - base_model.py (BaseModel 추상 클래스)
  - task_log.py (TaskLog 모델)
  - ocr_text_box.py (OCRTextBox 모델)
  - batch_execution.py (BatchExecution 모델)
  - chain_execution.py (ChainExecution 모델)
  - ocr_execution.py (OCRExecution 모델)

✓ 함수 분석 (1개):
  - ocr_stage.py의 _save_batch_db() 메서드

================================================================================
  2. 주요 발견 사항
================================================================================

2.1 모델 아키텍처
  - Base: 모든 모델의 기본 클래스 (created_at, updated_at 자동 관리)
  - 6개의 도메인 모델로 이루어진 계층 구조
  - 3개의 1:N 관계 정의

2.2 관계 구조
  ┌─ BatchExecution (배치 처리 단위)
  │  └─ ChainExecution (이미지 단위 처리)
  │     └─ TaskLog (Celery 작업 로그)
  │
  └─ OCRExecution (OCR 처리 메타데이터)
     └─ OCRTextBox (추출된 텍스트)

2.3 _save_batch_db 함수의 역할
  - 배치 OCR 결과를 DB에 저장하는 핵심 함수
  - 각 이미지마다 개별 ChainExecution 생성
  - 개별 이미지의 OCRExecution과 OCRTextBox 저장

================================================================================
  3. 발견된 문제점 (4가지)
================================================================================

HIGH 우선순위:

1. 트랜잭션 원자성 부재
   - 각 create() 함수가 개별적으로 commit
   - 부분 실패 시 롤백 불가능
   - 1000개 중 500번째 실패 시 499개만 저장됨

2. BatchExecution 진행 상태 미업데이트
   - completed_images/failed_images 미업데이트
   - API 조회 시 진행률 0%로 표시
   - get_progress_percentage() 메서드 사용 불가

3. 에러 핸들링 부재
   - 한 이미지 저장 실패 시 전체 배치 중단
   - 실패 원인 추적 불가능
   - 배치 상태 일관성 깨짐

MEDIUM 우선순위:

4. N+1 쿼리 패턴
   - 1000개 이미지 × 5개 텍스트박스 = 5000개 쿼리
   - 메모리 사용량 증가
   - DB 연결 풀 고갈

================================================================================
  4. 권장 개선안
================================================================================

[Phase 1] 긴급 개선 - 우선순위 순서:

1단계: 트랜잭션 관리 개선
  - 현재: 각 add() 후 즉시 commit
  - 개선: 모든 add() 후 마지막에 한 번만 commit
  - 파일: /packages/celery_worker/tasks/stages/ocr_stage.py
  - 함수: _save_batch_db() (라인 384-465)

2단계: 에러 핸들링 추가
  - try-except 구조로 감싸기
  - 개별 이미지 실패 시 다음 이미지 계속 처리
  - 실패한 이미지 목록 기록

3단계: 진행 상태 업데이트
  - BatchExecution을 함수 파라미터로 받기
  - 저장 완료 시 increment_completed_images() 호출
  - 저장 실패 시 increment_failed_images() 호출
  - 최종적으로 complete_execution() 호출

[Phase 2] 성능 개선:

4단계: Bulk Insert 적용
  - OCRTextBox 일괄 저장 (bulk_insert_mappings)
  - 쿼리 수 대폭 감소

5단계: 로깅 개선
  - 저장된 데이터 수 검증
  - 성공/실패 통계 기록

================================================================================
  5. 모델 세부 정보
================================================================================

BatchExecution:
  - PK: id, UNIQUE: batch_id
  - 상태: PENDING/STARTED/SUCCESS/FAILURE
  - 통계: total_images, completed_images, failed_images
  - 메서드: start_execution(), complete_execution(), get_progress_percentage()

ChainExecution:
  - PK: id, FK: batch_id
  - 상태: PENDING/STARTED/SUCCESS/FAILURE
  - 통계: total_tasks, completed_tasks, failed_tasks
  - 메서드: increment_completed_tasks(), increment_failed_tasks()

TaskLog:
  - PK: id, UNIQUE: task_id
  - FK: chain_execution_id
  - 상태: PENDING/STARTED/SUCCESS/FAILURE/RETRY/REVOKED

OCRExecution:
  - PK: id, UNIQUE: image_path, public_path
  - FK: chain_id
  - 상태: success/failed
  - Cascade: text_boxes (1:N, delete-orphan)

OCRTextBox:
  - PK: id, FK: ocr_execution_id
  - 필드: text, confidence (0.0~1.0), bbox (JSON)

================================================================================
  6. ProcessStatus Enum
================================================================================

PENDING    - 대기 중
STARTED    - 시작됨
SUCCESS    - 성공
RUNNING    - 진행 중
FAILURE    - 실패
RETRY      - 재시도
REVOKED    - 취소됨

================================================================================
  7. _save_batch_db 현재 동작 흐름
================================================================================

입력: context.ocr_results (List[OCRExtractDTO])

1. 각 이미지마다:
   a) 개별 chain_id 생성 (uuid.uuid4())
   b) ChainExecution 생성 (batch_id 참조)
   c) OCRExecution 생성 (chain_id 참조)
   d) OCRTextBox 저장 (개별 DB 쿼리)

출력: DB에 데이터 저장됨

문제: 각 단계마다 개별 commit → 원자성 부재

================================================================================
  8. 생성된 분석 결과물
================================================================================

✓ 상세 분석 보고서: /tmp/모델_분석_결과.md
  - 각 모델의 상세 구조 (필드, 관계, 인덱스, 메서드)
  - 시각화된 관계도
  - 데이터 플로우 다이어그램
  - 개선 방안 상세 설명

✓ 최종 요약 문서: /tmp/최종_요약.md
  - 핵심 요점 정리
  - 문제점별 상세 분석
  - 개선 계획 (Phase 별)
  - 사용 예시

✓ 메모리 저장: 모델_관계_분석.md
  - 향후 참고 가능한 핵심 정보

================================================================================
  9. 다음 단계
================================================================================

1. _save_batch_db 함수 리팩토링
   - 트랜잭션 관리 개선
   - 에러 핸들링 추가
   - 진행 상태 업데이트

2. 단위 테스트 작성
   - 정상 케이스 (100개 이미지)
   - 부분 실패 케이스 (500번째 실패)
   - 대량 데이터 케이스 (1000개 이미지)

3. 통합 테스트
   - 배치 전체 플로우 검증
   - DB 데이터 검증
   - 진행 상태 업데이트 확인

4. 성능 테스트
   - Bulk Insert 성능 개선율 측정
   - DB 쿼리 수 감소 확인

================================================================================

분석 완료 - 2025-11-13

