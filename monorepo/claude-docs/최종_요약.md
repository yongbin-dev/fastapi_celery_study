# 모델 구조 및 관계 분석 - 최종 요약

## 프로젝트 모델 아키텍처

이 프로젝트는 **배치 기반 OCR 처리 파이프라인**을 위한 모델 구조입니다.

---

## 1. 모델 간 관계도 (시각화)

```
┌─────────────────────────────────────────────────────────────────┐
│                     BatchExecution                              │
│  배치 전체 상태 관리 (100개 이미지 처리 등)                     │
│                                                                  │
│  - batch_id (UNIQUE)      - total_images                        │
│  - batch_name             - completed_images                    │
│  - status                 - failed_images                       │
│  - chunk_size (10)        - total_chunks                        │
└──────────────────────────────┬──────────────────────────────────┘
                               │ FK: batch_id (1:N)
                               │
        ┌──────────────────────┴──────────────────────┐
        │                                             │
        │                                             │
    ┌───▼────────────────────────┐    ┌───────────────▼──────────────┐
    │   ChainExecution           │    │   ChainExecution             │
    │  (이미지1 처리)            │    │  (이미지2 처리)              │
    │                            │    │                              │
    │  - chain_id (개별)         │    │  - chain_id (개별)           │
    │  - batch_id                │    │  - batch_id                  │
    │  - chain_name              │    │  - chain_name                │
    │  - total_tasks = 1         │    │  - total_tasks = 1           │
    │  - status                  │    │  - status                    │
    └───┬────────────────────────┘    └───┬──────────────────────────┘
        │                                  │
        │ FK: chain_execution_id (1:N)    │
        │                                  │
    ┌───▼────────────────────┐    ┌──────▼────────────────┐
    │   TaskLog              │    │   TaskLog             │
    │ (Celery 작업 로그)     │    │ (Celery 작업 로그)   │
    └────────────────────────┘    └───────────────────────┘


독립적인 트리 구조:

┌────────────────────────────┐
│    OCRExecution            │
│  (OCR 실행 메타데이터)     │
│                            │
│  - chain_id (FK)           │
│  - image_path (UNIQUE)     │
│  - public_path (UNIQUE)    │
│  - status (success/failed) │
└────────────┬───────────────┘
             │ FK: ocr_execution_id (1:N)
             │ CASCADE: delete
             │
        ┌────▼────────────────┐
        │  OCRTextBox         │
        │ (텍스트 박스)       │
        │                     │
        │  - text             │
        │  - confidence       │
        │  - bbox (JSON)      │
        └─────────────────────┘
```

---

## 2. 모델별 핵심 정보 정리

### BatchExecution (배치 실행)
**역할**: 배치 처리 전체의 상태를 관리하고 진행률을 추적

| 필드 | 타입 | 설명 |
|------|------|------|
| batch_id | String(255) | UNIQUE - 배치 고유 ID |
| batch_name | String(255) | 배치 이름 |
| status | String(20) | PENDING/STARTED/SUCCESS/FAILURE |
| total_images | Integer | 처리할 총 이미지 수 |
| completed_images | Integer | 완료된 이미지 수 |
| failed_images | Integer | 실패한 이미지 수 |
| total_chunks | Integer | 총 청크 수 |
| chunk_size | Integer | 청크당 이미지 수 (기본값: 10) |
| started_at | DateTime | 시작 시간 |
| finished_at | DateTime | 완료 시간 |
| final_result | JSON | 최종 결과 |

**자동 완료 로직**: `_check_and_complete_execution()` - 처리된 이미지(완료+실패) >= 총 이미지 수이면 SUCCESS 또는 FAILURE로 자동 전환

---

### ChainExecution (체인 실행)
**역할**: 각 이미지의 처리 과정(workflow)을 추적

| 필드 | 타입 | 설명 |
|------|------|------|
| chain_id | String(255) | 체인 고유 ID |
| batch_id | String(255) | FK: 소속 배치 ID |
| chain_name | String(255) | 체인 이름 |
| celery_task_id | String(255) | 첫 번째 Celery Task ID |
| status | String(20) | PENDING/STARTED/SUCCESS/FAILURE |
| total_tasks | Integer | 체인 내 작업 수 (OCR, Layout, LLM 등) |
| completed_tasks | Integer | 완료된 작업 수 |
| failed_tasks | Integer | 실패한 작업 수 |
| started_at | DateTime | 시작 시간 |
| finished_at | DateTime | 완료 시간 |
| input_data | JSON | 입력 데이터 (이미지 경로, 인덱스 등) |
| final_result | JSON | 최종 결과 |

**_save_batch_db에서 생성 예시**:
```python
ChainExecution(
    chain_id=str(uuid.uuid4()),  # 각 이미지마다 개별
    batch_id=context.batch_id,    # 같은 배치
    chain_name="batch_image_0",   # 이미지 인덱스
    total_tasks=1,                # 고정
    status="PENDING"              # 기본값
)
```

---

### TaskLog (작업 로그)
**역할**: Celery 작업의 생명주기를 추적

| 필드 | 타입 | 설명 |
|------|------|------|
| task_id | String(255) | UNIQUE - Celery Task ID |
| task_name | String(255) | 작업 함수명 |
| chain_execution_id | Integer | FK: 소속 체인 |
| status | String(50) | PENDING/STARTED/SUCCESS/FAILURE/RETRY/REVOKED |
| started_at | DateTime | 시작 시간 |
| finished_at | DateTime | 완료 시간 |
| retries | Integer | 재시도 횟수 |
| error | String(512) | 에러 메시지 |

---

### OCRExecution (OCR 실행)
**역할**: 개별 이미지의 OCR 처리 메타데이터

| 필드 | 타입 | 설명 |
|------|------|------|
| chain_id | String(255) | FK: 소속 체인 |
| image_path | String(255) | UNIQUE - 이미지 경로 |
| public_path | String(255) | UNIQUE - 공개 경로 |
| status | String(50) | success/failed |
| error | Text | 에러 메시지 |

**Relationship**: `text_boxes` (1:N, CASCADE DELETE) - OCRExecution 삭제 시 모든 text_boxes 자동 삭제

---

### OCRTextBox (텍스트 박스)
**역할**: OCR로 추출된 개별 텍스트 박스 정보

| 필드 | 타입 | 설명 |
|------|------|------|
| ocr_execution_id | Integer | FK: 소속 OCR 실행 |
| text | Text | 추출된 텍스트 |
| confidence | Float | 신뢰도 (0.0~1.0) |
| bbox | JSON | [[x1,y1], [x2,y2], [x3,y3], [x4,y4]] |

---

## 3. `_save_batch_db` 함수의 현재 상태

### 위치
`/packages/celery_worker/tasks/stages/ocr_stage.py` - 라인 384~465

### 데이터 저장 흐름

```
context.ocr_results (OCRExtractDTO 리스트)
        │
        ├─→ [0] image0_ocr_result
        │   ├─→ ChainExecution {chain_id: uuid_0, batch_id: "batch_001"}
        │   ├─→ OCRExecution {chain_id: uuid_0, image_path: "path0"}
        │   └─→ OCRTextBox[] {5개 텍스트 박스}
        │
        ├─→ [1] image1_ocr_result
        │   ├─→ ChainExecution {chain_id: uuid_1, batch_id: "batch_001"}
        │   ├─→ OCRExecution {chain_id: uuid_1, image_path: "path1"}
        │   └─→ OCRTextBox[] {3개 텍스트 박스}
        │
        └─→ [N] imageN_ocr_result
            ├─→ ChainExecution {chain_id: uuid_N, batch_id: "batch_001"}
            ├─→ OCRExecution {chain_id: uuid_N, image_path: "pathN"}
            └─→ OCRTextBox[] {N개 텍스트 박스}
```

### 코드 구조

```python
def _save_batch_db(self, context: PipelineContext):
    ocr_results = context.ocr_results
    
    with get_db_manager().get_sync_session() as session:
        for idx, ocr_result in enumerate(ocr_results):
            # 1. 이미지 경로 추출
            image_path = context.private_imgs[idx]
            public_path = context.public_file_paths[idx]
            
            # 2. 개별 chain_id 생성
            individual_chain_id = str(uuid.uuid4())
            
            # 3. ChainExecution 생성
            chain_execution_crud.create_chain_execution(...)
            
            # 4. OCRExecution 생성
            ocr_execution_data = OCRExecutionCreate(
                chain_id=individual_chain_id,
                image_path=image_path,
                public_path=public_path,
                status="success" if ocr_result.text_boxes else "failed",
                error=""
            )
            db_ocr_execution = ocr_execution_crud.create(...)
            
            # 5. OCRTextBox 저장 (여러 개)
            for box in ocr_result.text_boxes:
                ocr_text_box_crud.create(...)
```

---

## 4. 현재 구현의 문제점 분석

### 4.1 문제점 1: 트랜잭션 원자성 부재 (높음 우선순위)

**문제**:
```python
chain_execution_crud.create_chain_execution(...)  # db.commit()
ocr_execution_crud.create(...)                    # db.commit()
for box in ocr_result.text_boxes:
    ocr_text_box_crud.create(...)                 # db.commit()
```

각 create() 함수가 내부적으로 `db.commit()`을 호출합니다.

**결과**:
- 1000개 이미지 중 500번째에서 실패하면, 499개는 DB에 저장되고 501개는 저장 안됨
- 부분 성공/부분 실패 상태가 발생
- 롤백이 불가능

**개선안**:
```python
try:
    for idx, ocr_result in enumerate(ocr_results):
        # 모든 데이터를 세션에만 add (commit 안함)
        session.add(chain_exec)
        session.add(ocr_execution)
        for box in ocr_result.text_boxes:
            session.add(text_box)
    
    # 마지막에 한 번만 commit
    session.commit()
except Exception as e:
    session.rollback()
    raise
```

### 4.2 문제점 2: BatchExecution 진행 상태 미업데이트 (높음 우선순위)

**문제**:
```python
# 현재: 아무도 이것을 업데이트하지 않음
batch_execution.completed_images = 500
batch_execution.failed_images = 0
```

**결과**:
- API에서 조회 시 진행률 0%로 표시됨
- 실시간 진행 상황을 알 수 없음
- `get_progress_percentage()` 메서드 사용 불가

**개선안**:
```python
# _save_batch_db 함수가 batch_execution을 파라미터로 받아서
def _save_batch_db(self, context: PipelineContext, batch_execution: BatchExecution):
    for idx, ocr_result in enumerate(ocr_results):
        # ... 저장 로직 ...
        
        # 진행 상태 업데이트
        if ocr_result.text_boxes:
            batch_execution.increment_completed_images()
        else:
            batch_execution.increment_failed_images()
```

### 4.3 문제점 3: N+1 쿼리 패턴 (중간 우선순위)

**문제**:
```python
for idx, ocr_result in enumerate(ocr_results):  # 1000번 반복
    for box in ocr_result.text_boxes:            # 5번 반복 (평균)
        ocr_text_box_crud.create(...)            # = 5000번 DB 쿼리
```

**결과**:
- 메모리 사용량 증가
- DB 연결 풀 고갈
- 느린 처리 속도

**개선안**:
```python
text_boxes_to_insert = []
for box in ocr_result.text_boxes:
    text_boxes_to_insert.append({
        'ocr_execution_id': db_ocr_execution.id,
        'text': box.text,
        'confidence': box.confidence,
        'bbox': box.bbox
    })

# Bulk insert (한 번의 쿼리)
session.bulk_insert_mappings(OCRTextBox, text_boxes_to_insert)
```

### 4.4 문제점 4: 에러 핸들링 부재 (높음 우선순위)

**문제**:
```python
def _save_batch_db(self, context: PipelineContext):
    with get_db_manager().get_sync_session() as session:
        for idx, ocr_result in enumerate(ocr_results):
            # 에러 처리 없음
```

**결과**:
- 한 이미지 저장 실패하면 전체 배치 처리 중단
- 어느 이미지가 실패했는지 추적 불가
- 배치 상태 미업데이트

**개선안**:
```python
failed_images = []
for idx, ocr_result in enumerate(ocr_results):
    try:
        # 저장 로직
    except Exception as e:
        logger.error(f"Image {idx} save failed: {e}")
        failed_images.append((idx, str(e)))
        batch_execution.increment_failed_images()
        continue

if failed_images:
    logger.warning(f"Failed to save {len(failed_images)} images: {failed_images}")
```

---

## 5. 권장 개선 계획

### Phase 1: 긴급 개선 (즉시)

1. **트랜잭션 관리 개선**
   - 파일: `ocr_stage.py`
   - 함수: `_save_batch_db`
   - 변경: 모든 add() 후 마지막에 한 번만 commit

2. **에러 핸들링 추가**
   - try-except-finally 구조
   - 개별 이미지 실패 시 다음 이미지 계속 처리

3. **BatchExecution 상태 업데이트**
   - `increment_completed_images()`/`increment_failed_images()` 호출
   - 최종 `complete_execution()` 호출

### Phase 2: 성능 개선 (1주일 내)

4. **Bulk Insert 적용**
   - OCRTextBox 일괄 저장

5. **로깅 개선**
   - 저장된 데이터 수 검증
   - 성공/실패 통계

### Phase 3: 최적화 (선택사항)

6. **메모리 최적화**
   - 스트리밍 처리
   - Generator 패턴 사용

---

## 6. ProcessStatus Enum 참고

```python
class ProcessStatus(str, Enum):
    PENDING = "PENDING"    # 대기 중
    STARTED = "STARTED"    # 시작됨
    SUCCESS = "SUCCESS"    # 성공
    RUNNING = "RUNNING"    # 진행 중
    FAILURE = "FAILURE"    # 실패
    RETRY = "RETRY"        # 재시도
    REVOKED = "REVOKED"    # 취소됨
```

---

## 7. 핵심 요점 정리

| 항목 | 설명 |
|------|------|
| **모델 계층** | Base → {TaskLog, ChainExecution, BatchExecution, OCRExecution, OCRTextBox} |
| **관계 구조** | Batch(1) ← Chain(N) ← Task(N) / OCRExec(1) ← TextBox(N) |
| **_save_batch_db 역할** | OCR 결과를 DB에 저장 (ChainExecution, OCRExecution, OCRTextBox) |
| **주요 문제점** | 트랜잭션, 에러 처리, 진행 상태 업데이트 미비 |
| **긴급 개선 사항** | 배치 커밋, 에러 핸들링, 상태 업데이트 |

