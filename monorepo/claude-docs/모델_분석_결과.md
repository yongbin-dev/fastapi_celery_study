# 모델 구조 분석 및 관계도 문서

## 1. 모델 개요

### 1.1 모델 목록
- **Base**: 모든 모델의 기본 클래스 (created_at, updated_at 필드 포함)
- **TaskLog**: Celery 작업 생명주기 추적
- **ChainExecution**: 체인(workflow) 실행 상태 추적
- **BatchExecution**: 배치 이미지 처리 상태 추적
- **OCRExecution**: OCR 작업 메타데이터
- **OCRTextBox**: OCR 추출 결과의 개별 텍스트 박스

---

## 2. 각 모델의 상세 구조

### 2.1 Base (기본 클래스)
```
파일: base.py
상속: DeclarativeBase

필드:
- created_at: DateTime (기본값: datetime.now, NOT NULL)
- updated_at: DateTime (기본값: datetime.now, onupdate: datetime.now, NOT NULL)

설명: 모든 모델이 상속하는 기본 클래스로 타임스탬프 자동 관리
```

### 2.2 TaskLog
```
테이블명: task_logs

필드:
- id (PK): Integer
- task_id: String(255) - UNIQUE, INDEX - Celery 작업 ID
- task_name: String(255) - INDEX - 작업 함수명 (예: app.tasks.send_email)
- status: String(50) - INDEX - 작업 상태 (PENDING/STARTED/SUCCESS/FAILURE/RETRY/REVOKED)
- error: String(512) - 에러 메시지
- started_at: DateTime - INDEX - 작업 시작 시간
- finished_at: DateTime - 작업 완료 시간
- retries: Integer (기본값: 0) - 재시도 횟수
- chain_execution_id: Integer - FK → chain_executions.id (ondelete="SET NULL")
- created_at: DateTime (Base에서 상속)
- updated_at: DateTime (Base에서 상속)

관계:
- chain_execution: ChainExecution (back_populates="task_logs")

인덱스:
- PK: id
- UNIQUE: task_id
- INDEX: task_name, status
- COMPOSITE: (task_name, status)
- COMPOSITE: (started_at DESC)
- COMPOSITE: (chain_execution_id, status)
```

### 2.3 ChainExecution
```
테이블명: chain_executions

필드:
- id (PK): Integer
- chain_id: String(255) - INDEX - 체인 고유 ID
- celery_task_id: String(255) - INDEX - 첫 번째 Celery task ID
- chain_name: String(255) - INDEX - 체인 이름
- batch_id: String(255) - FK → batch_executions.batch_id - 배치 실행 ID
- status: String(20) - INDEX (기본값: PENDING) - 체인 상태
- total_tasks: Integer (기본값: 0) - 체인 내 총 작업 수
- completed_tasks: Integer (기본값: 0) - 완료된 작업 수
- failed_tasks: Integer (기본값: 0) - 실패한 작업 수
- started_at: DateTime - 시작 시간
- finished_at: DateTime - 완료 시간
- initiated_by: String(100) - 시작한 사용자/시스템
- input_data: JSON - 입력 데이터
- final_result: JSON - 최종 결과
- error_message: Text - 오류 메시지
- created_at: DateTime (Base에서 상속)
- updated_at: DateTime (Base에서 상속)

관계:
- task_logs: TaskLog (back_populates="chain_execution")
- batch_execution: BatchExecution (backref, FK: batch_id)

인덱스:
- PK: id
- INDEX: chain_id, celery_task_id, chain_name, batch_id, status
- COMPOSITE: (status, started_at)
- COMPOSITE: (chain_name, status)

주요 메서드:
- start_execution(): 체인 실행 시작
- complete_execution(success, final_result, error_message): 체인 완료
- increment_completed_tasks(count): 완료 작업 수 증가
- increment_failed_tasks(count): 실패 작업 수 증가
- _check_and_complete_execution(): 자동 완료 상태 확인
```

### 2.4 BatchExecution
```
테이블명: batch_executions

필드:
- id (PK): Integer
- batch_id: String(255) - UNIQUE, INDEX - 배치 고유 ID
- batch_name: String(255) - INDEX - 배치 이름
- status: String(20) - INDEX (기본값: PENDING) - 배치 상태
- total_images: Integer (기본값: 0) - 총 이미지 수
- completed_images: Integer (기본값: 0) - 완료된 이미지 수
- failed_images: Integer (기본값: 0) - 실패한 이미지 수
- total_chunks: Integer (기본값: 0) - 총 청크 수
- completed_chunks: Integer (기본값: 0) - 완료된 청크 수
- failed_chunks: Integer (기본값: 0) - 실패한 청크 수
- chunk_size: Integer (기본값: 10) - 청크당 이미지 수
- started_at: DateTime - 시작 시간
- finished_at: DateTime - 완료 시간
- initiated_by: String(100) - 시작한 사용자/시스템
- input_data: JSON - 입력 데이터 (이미지 경로 등)
- options: JSON - 파이프라인 옵션
- final_result: JSON - 최종 결과
- error_message: Text - 오류 메시지
- created_at: DateTime (Base에서 상속)
- updated_at: DateTime (Base에서 상속)

관계:
- chain_executions: ChainExecution (1:N 관계)

인덱스:
- PK: id
- UNIQUE: batch_id
- INDEX: batch_id, batch_name, status
- COMPOSITE: (status, started_at)
- COMPOSITE: (batch_name, status)

주요 메서드:
- start_execution(): 배치 실행 시작
- complete_execution(success, final_result, error_message): 배치 완료
- increment_completed_images(count): 완료 이미지 증가
- increment_failed_images(count): 실패 이미지 증가
- increment_completed_chunks(count): 완료 청크 증가
- increment_failed_chunks(count): 실패 청크 증가
- _check_and_complete_execution(): 자동 완료 상태 확인
- get_progress_percentage(): 진행률 계산 (0-100)
```

### 2.5 OCRExecution
```
테이블명: ocr_executions

필드:
- id (PK): Integer
- chain_id: String(255) - INDEX - Celery chain ID (선택적)
- image_path: String(255) - UNIQUE, INDEX - 이미지 경로
- public_path: String(255) - UNIQUE, INDEX - 이미지 공개 경로
- status: String(50) - INDEX - 처리 상태 (success/failed)
- error: Text - 에러 메시지 (실패 시)
- created_at: DateTime (Base에서 상속)
- updated_at: DateTime (Base에서 상속)

관계:
- text_boxes: OCRTextBox (1:N, cascade="all, delete-orphan", lazy="selectin")

인덱스:
- PK: id
- UNIQUE: image_path, public_path
- INDEX: chain_id, status
```

### 2.6 OCRTextBox
```
테이블명: ocr_text_boxes

필드:
- id (PK): Integer
- ocr_execution_id: Integer - FK → ocr_executions.id (ondelete="CASCADE")
- text: Text - 추출된 텍스트
- confidence: Float - 신뢰도 점수 (0.0~1.0)
- bbox: JSON - 바운딩 박스 좌표 [[x1,y1], [x2,y2], [x3,y3], [x4,y4]]
- created_at: DateTime (Base에서 상속)
- updated_at: DateTime (Base에서 상속)

관계:
- ocr_execution: OCRExecution (back_populates="text_boxes")

인덱스:
- PK: id
- INDEX: ocr_execution_id
- INDEX: confidence
```

---

## 3. 모델 간 관계도

```
                              ┌─────────────────┐
                              │ BatchExecution  │
                              │                 │
                              │ - batch_id (PK) │
                              │ - status        │
                              │ - total_images  │
                              └────────┬────────┘
                                       │
                                       │ FK: batch_id
                                       │
                              ┌────────▼────────┐
                              │ ChainExecution  │
                              │                 │
                              │ - chain_id (PK) │
                              │ - batch_id (FK) │
                              │ - status        │
                              └────────┬────────┘
                                       │
                                       │ 1:N relationship
                                       │ task_logs
                                       │
                              ┌────────▼────────┐
                              │   TaskLog       │
                              │                 │
                              │ - task_id (PK)  │
                              │ - chain_id (FK) │
                              └─────────────────┘


                   (독립적인 트리 구조)
                              
                   ┌─────────────────┐
                   │ OCRExecution    │
                   │                 │
                   │ - chain_id (FK) │
                   │ - image_path    │
                   │ - public_path   │
                   └────────┬────────┘
                            │
                            │ 1:N relationship
                            │ text_boxes
                            │
                   ┌────────▼────────┐
                   │  OCRTextBox     │
                   │                 │
                   │ - ocr_exec_id   │
                   │ - text          │
                   │ - confidence    │
                   │ - bbox          │
                   └─────────────────┘
```

### 3.1 관계 요약

| 관계 | 부모 | 자식 | 타입 | FK 필드 | 설명 |
|------|------|------|------|---------|------|
| Batch→Chain | BatchExecution | ChainExecution | 1:N | batch_id | 배치 내 여러 체인 |
| Chain→Task | ChainExecution | TaskLog | 1:N | chain_execution_id | 체인 내 여러 작업 |
| OCRExec→TextBox | OCRExecution | OCRTextBox | 1:N | ocr_execution_id | OCR 실행 내 여러 텍스트박스 |

---

## 4. `_save_batch_db` 함수 분석

### 4.1 현재 구현 위치
- 파일: `/packages/celery_worker/tasks/stages/ocr_stage.py`
- 클래스: `OCRStage`
- 메서드: `_save_batch_db(self, context: PipelineContext)` (라인 384-465)

### 4.2 현재 구현 흐름

```python
def _save_batch_db(self, context: PipelineContext):
    """배치 OCR 결과를 DB에 저장
    
    각 이미지마다 개별 chain_id를 생성하여 저장합니다.
    """
    # 1. 입력 검증
    - ocr_results가 비어있으면 return
    
    # 2. DB 세션 획득
    - get_db_manager().get_sync_session()
    
    # 3. 각 이미지마다 반복 (for idx, ocr_result in enumerate(ocr_results))
       a) 이미지 경로 추출
          - image_path = context.private_imgs[idx]
          - public_path = context.public_file_paths[idx]
       
       b) 개별 chain_id 생성
          - individual_chain_id = str(uuid.uuid4())
       
       c) ChainExecution 생성
          - chain_execution_crud.create_chain_execution(
              chain_id=individual_chain_id,
              batch_id=context.batch_id,
              chain_name=f"batch_image_{idx}",
              total_tasks=1,
              initiated_by="batch_ocr",
              input_data={"image_path": image_path, "index": idx}
            )
       
       d) OCRExecution 생성
          - status = "success" if ocr_result.text_boxes else "failed"
          - ocr_execution_crud.create(...)
       
       e) 텍스트 박스 저장
          - for box in ocr_result.text_boxes:
              ocr_text_box_crud.create(...)
    
    # 4. 완료 로깅
```

### 4.3 데이터 플로우

```
context.ocr_results (List[OCRExtractDTO])
        │
        ├─→ ocr_result[0]
        │   ├─→ ChainExecution (chain_id_0)
        │   ├─→ OCRExecution (chain_id_0 참조)
        │   └─→ OCRTextBox[] (ocr_execution_id 참조)
        │
        ├─→ ocr_result[1]
        │   ├─→ ChainExecution (chain_id_1)
        │   ├─→ OCRExecution (chain_id_1 참조)
        │   └─→ OCRTextBox[] (ocr_execution_id 참조)
        │
        └─→ ocr_result[N]
            ├─→ ChainExecution (chain_id_N)
            ├─→ OCRExecution (chain_id_N 참조)
            └─→ OCRTextBox[] (ocr_execution_id 참조)
```

### 4.4 저장되는 데이터 상세

#### ChainExecution 데이터
```python
{
    'chain_id': str(uuid.uuid4()),      # 각 이미지마다 고유
    'batch_id': context.batch_id,       # 배치 ID (같음)
    'chain_name': f'batch_image_{idx}', # 이미지 인덱스
    'total_tasks': 1,                   # 항상 1
    'initiated_by': 'batch_ocr',        # 고정값
    'input_data': {                     # 이미지 정보
        'image_path': image_path,
        'index': idx
    },
    'status': 'PENDING' (기본값)
}
```

#### OCRExecution 데이터
```python
{
    'chain_id': individual_chain_id,    # ChainExecution의 chain_id와 동일
    'image_path': image_path,
    'public_path': public_path,
    'status': 'success' or 'failed',    # text_boxes 여부로 판단
    'error': '' or 'No text boxes extracted'
}
```

#### OCRTextBox 데이터 (여러 개)
```python
{
    'ocr_execution_id': db_ocr_execution.id,
    'text': box.text,
    'confidence': box.confidence,
    'bbox': box.bbox  # JSON 형식: [[x1,y1], [x2,y2], ...]
}
```

### 4.5 현재 구현의 특징

#### 장점
1. **각 이미지마다 개별 chain_id 생성**
   - 각 이미지의 처리 과정을 독립적으로 추적 가능
   - 개별 이미지 실패 시 다른 이미지 영향 없음

2. **명확한 계층 구조**
   - BatchExecution → ChainExecution (이미지별) → OCRExecution → OCRTextBox
   - 배치 내 개별 이미지 추적이 명확함

3. **상태 추적**
   - 각 ChainExecution에서 진행률 계산 가능
   - OCRExecution의 성공/실패 상태 명확

4. **Cascade 설정**
   - OCRExecution 삭제 시 OCRTextBox 자동 삭제
   - ChainExecution 삭제 시 TaskLog 자동 삭제

#### 잠재적 문제점

1. **N+1 쿼리 가능성**
   ```python
   for idx, ocr_result in enumerate(ocr_results):
       # 각 반복마다 DB 쿼리 (중첩 트랜잭션)
       chain_execution_crud.create_chain_execution(...)  # 커밋
       ocr_execution_crud.create(...)                    # 커밋
       for box in ocr_result.text_boxes:
           ocr_text_box_crud.create(...)                 # 각 박스마다 커밋
   ```

2. **트랜잭션 관리**
   - 각 create() 함수가 내부적으로 commit() 호출
   - 부분 실패 시 롤백 불가능
   - 배치 중간에 실패하면 일부만 DB에 저장됨

3. **메모리 효율성**
   - 모든 ocr_results를 메모리에 유지
   - 대규모 배치에서 메모리 압박 가능

4. **ChainExecution 상태 관리**
   - total_tasks=1로 고정
   - ChainExecution의 자동 완료 로직이 작동할 기회 없음
   - 수동으로 상태 업데이트 필요

### 4.6 개선 방안

#### 1. 배치 트랜잭션 처리
```python
# 현재 코드
db.add(chain_exec)
db.commit()  # 즉시 커밋

# 개선안
db.add(chain_exec)
# 일괄 commit (마지막에 한 번만)
```

#### 2. 에러 핸들링 강화
```python
try:
    for idx, ocr_result in enumerate(ocr_results):
        # 처리
except Exception as e:
    # 배치 전체 실패 처리
    logger.error(...)
    raise
finally:
    # 정리 작업
```

#### 3. 진행 상태 업데이트
```python
# BatchExecution의 completed_images/failed_images 업데이트
batch.increment_completed_images()
# 또는
batch.increment_failed_images()
```

#### 4. 대량 데이터 처리 (bulk insert)
```python
# 현재
for box in ocr_result.text_boxes:
    ocr_text_box_crud.create(...)  # 1개씩

# 개선안
db.bulk_insert_mappings(OCRTextBox, [
    {'ocr_execution_id': exec_id, 'text': box.text, ...}
    for box in ocr_result.text_boxes
])
```

---

## 5. ProcessStatus Enum

```python
class ProcessStatus(str, Enum):
    PENDING = "PENDING"    # 대기 중
    STARTED = "STARTED"    # 시작됨
    SUCCESS = "SUCCESS"    # 성공
    RUNNING = "RUNNING"    # 진행 중
    FAILURE = "FAILURE"    # 실패
    RETRY = "RETRY"        # 재시도
    REVOKED = "REVOKED"    # 취소됨
```

---

## 6. 권장 개선 우선순위

### 높음
1. **트랜잭션 관리 개선**: 배치 단위 커밋으로 원자성 보장
2. **에러 핸들링**: 부분 실패 시 롤백 메커니즘
3. **진행 상태 추적**: BatchExecution의 completed_images 업데이트

### 중간
4. **Bulk Insert**: OCRTextBox 대량 저장 성능 개선
5. **로깅 개선**: 저장된 데이터 수 검증

### 낮음
6. **메모리 최적화**: 스트리밍 처리로 메모리 사용량 감소
7. **캐싱**: 반복 조회 캐싱

---

## 7. 모델 사용 예시

### 배치 실행 플로우
```python
# 1. BatchExecution 생성
batch = BatchExecution(
    batch_id="batch_001",
    batch_name="Invoice_Batch_20231115",
    status=ProcessStatus.PENDING,
    total_images=100,
    chunk_size=10
)
session.add(batch)
session.commit()

# 2. 배치 시작
batch.start_execution()

# 3. 각 이미지마다
for img in images:
    # 3.1 ChainExecution 생성
    chain = ChainExecution(
        chain_id=uuid.uuid4(),
        batch_id=batch.batch_id,
        chain_name=f"image_process_{img.id}",
        total_tasks=4  # OCR, Layout, LLM, etc.
    )
    session.add(chain)
    
    # 3.2 OCRExecution 생성
    ocr_exec = OCRExecution(
        chain_id=chain.chain_id,
        image_path=img.private_path,
        public_path=img.public_path,
        status="success"
    )
    session.add(ocr_exec)
    
    # 3.3 OCRTextBox 저장
    for box in ocr_result.text_boxes:
        text_box = OCRTextBox(
            ocr_execution_id=ocr_exec.id,
            text=box.text,
            confidence=box.confidence,
            bbox=box.bbox
        )
        session.add(text_box)
    
    session.commit()
    
    # 4. 진행 상태 업데이트
    batch.increment_completed_images()

# 5. 배치 완료
batch.complete_execution(success=True)
session.commit()
```

